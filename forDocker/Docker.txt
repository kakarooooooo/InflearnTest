명령어

docker pull "image"[:version] => [version에 해당하는] "image" 다운로드

docker image ls => 설치된 이미지 목록 조회

docker image rm [-f] "id or image" => "id or image"에 해당하는 이미지 삭제 [강제 삭제]
docker image rm $(docker images -q) => 컨테이너에 실행중이지 않은 모든 이미지 삭제

docker create "iamge" => image에 해당하는 컨테이너 생성(없으면 pull)

docker start "id" => "id"에 해당하는 컨테이너 실행

docker ps => 실행중인 컨테이너 조회
docker ps -a => 중단된 컨테이너 포함한 모든 목록 조회

docker stop "id" => "id"에 해당하는 컨테이너 중단
docker kill "id" => "id"에 해당하는 컨테이너 "강제"중단

docker rm "id" => "id"에 해당하는 컨테이너 삭제 (중지된 것만)
docker rm $(docker ps -qa) => 중지된 모든 컨테이너 삭제
docker rm -f "id" => 실행되고 있는 컨테이너도 강제 삭제

docker run "image" => image에 해당하는 컨테이너 생성 및 실행(없으면 pull) - foreground에서 실행
docker run -d "image" => background에서 실행
docker run -d --name "이름" "image => "이름"으로 이름붙여서 컨테이너 생성 및 실행
docker run -d -p "4000(호스트 포트):80(컨테이너 포트)" "image" =>  "4000:80 포트"에서 "image" 컨테이너 생성 및 실행

docker logs "id" => "id" 컨테이너 로그 확인
docker logs --tail 10 "id" => 마지막 10줄만 출력
docker logs -f "id" => 실시간으로 생성되는 로그들도 모여줌

docker exec -it "id" bash => 컨테이너 내부에 접속

docker run -e MYSQL_ROOT_PASSWORD="비밀번호" -d -p 3306:3306 -v 호스트경로:/var/lib/mysql(컨테이너 내부 주소값) mysql => mysql을 "비밀번호"의 글로벌 비밀번호로 3306:3306 포트에 "호스트 경로"에 데이터를 저장해 실행
	windows에서 안될경우 - 주소를 "호스트경로:/var/lib/mysql(컨테이너 내부 주소값)" 으로 ""을 붙여주기 or c:/users/user_name/downloads처럼 드라이브 경로부터 작성


베이스 이미지 생성 (jdk17 사용)
FROM "image":"tag" => "image[:tag]"에 해당하는 베이스 이미지(컨테이너에 기본적으로 깔려있는 프로그램) 생성
 - 생성할 경로에 Dockerfile 파일 생성
 - 해당 파일에 
	FROM "eclipse-temurin:17-jdk" 

	ENTRYPOINT ["/bin/bash", "-c", "sleep 500"] # 500초동안 시스템을 일시정지 시키는 명령
    작성
 - 터미널에서 'docker build -t "imagename[:tag]" .' 실행
 - 'docker image ls' => 이미지 리스트 확인


COPY => 호스트 컴퓨터에서 컨테이너 컴퓨터로 파일 복사
COPY [호스트 컴퓨터 경로] [컨테이너 컴퓨터 경로]
	FROM ubuntu

	COPY app.txt /app.txt	#파일 하나
	COPY myapp /myapp/	#폴더 복사
	COPY *.txt /text/		#.txt로 된 파일을 text폴더에 복사
	COPY ./ /			#현재 경로 전체 복사

	ENTRYPOINT ["/bin/bash", "-c", "sleep 500"]


.dockerignore => 안에 있는 파일은 무시


ENTRYPOINT => 컨테이너가 시작할 떄 실행되는 명령어
	FROM ubuntu

	ENTRYPOINT ["/bin/bash", "-c", "echo hello"]


RUN => 이미지 생성 과정에서 실행시킬 명령어
	FROM ubuntu

	RUN apt update && apt install -y git	#git 설치 명령어를 이미지 생성하며 실행

	ENTRYPOINT ["/bin/bash", "-c", "sleep 500"]


WORKDIR => 작업디렉토리를 지정 : 그 이후 명령어들은 해당 디렉토리에서 실행됨
	FROM ubuntu

	WORKDIR /my-dir	# my-dir 폴더 생성해서 이동

	COPY ./ ./

	ENTRYPOINT ["/bin/bash", "-c", "sleep 500"]


EXPOSE : 컨테이너 내부에서 어떤 포트에 실행되는지 문서화하는 역할


Docker Compose => 여러 Docker 컨테이너를 하나의 서비스로 간주해 하나의 묶음으로 관리할수 있게 해주는 기능
compose.yml 파일 생성
services:
	my-web-server:
		container_name: web-server
		image: mysql
		ports:
			- 3306:3306
		environment:
			MYSQL_ROOT_PASSWORD: password
		volums:
			- ./mysql_data:/var/lib/mysql
docker compose up -d => compose.yml을 이용해 컨테이너 생성/백그라운드 실행
docker compose ps => compose에 정의된 컨테이너만 보여줌
docker compose down => `docker-compose.yml`에 의해 생성된 모든 컨테이너, 네트워크, 볼륨(익명 볼륨)을 중지하고 제거하는 명령어
docker compose logs => compose관련 컨테이너 로그
docker compose up --build => 다시 빌드 후 컨테이너 실행
docker compose pull => compose에 있는 이미지를 pull


compose - docker build
services:
	my-server:
		build: .
		ports:
			- 8080:8080
docker compose up -d --build => compose up 할 때 새롭게 이미지 빌드


resources/application.yml
spring:
	datasource:
		url: jdbc:mysql://my-db:3306/mydb
		username: root
		password: password
		driver-class-name: com.mysql.cj.jdbc.Driver
compose.yml
services:
	my-server:
		buile: .
		ports:
			- 8080:8080
		depends_on:
			my-db:
				condition: service_healthy
	my-db:
		image: mysql
		environment:
			MYSQL_ROOT_PASSWORD: password
			MYSQL_DATABASE: mydb
		volums:
			- ./mysql_data:/var/lib/mysql
		ports:
			- 3306:3306
		healthcheck:
			test: [ "CMD", "mysqladmin", "ping" ]
			interval: 5s
			retries: 10


테스트 - 크롬에서 localhost:[호스트 포트]
nginx - 크롬 시크릿모드에서 실행


Windows에서 lsof, kill, sudo 명령어가 작동하지 않을 때 대처 방법

lsof - 사용 중인 포트 검색
netstat -ano | findstr [포트 번호]
netstat -ano | findstr 8080

kill - 프로세스 종료
taskkill /f /pid [프로세스 아이디]
taskkill /f /pid 8872

sudo - 관리자 권한으로 실행
실행시키고자 하는 터미널(cmd, powershell 등)을 마우스 우클릭 한 후 ‘관리자 권한으로 실행’ 메뉴를 누르면 된다. 


PostgreSQL 18 버전 이상부터는 데이터 디렉터리 경로가
기존의 /var/lib/postgresql/data에서 /var/lib/postgresql/<버전>/docker 형태로 변경되었습니다.
따라서 2025년 10월 기준으로 최신 버전은 PostgreSQL 18이므로
/var/lib/postgresql/18/docker 경로로 지정해야 오류가 발생하지 않습니다.



